# NEAT Fruit Catcher AI üçéü§ñ

## Overview

This project explores the power of evolutionary neural networks using the NEAT (NeuroEvolution of Augmenting Topologies) algorithm. It features a simple "Fruit Catcher" game, built with Pygame, where an AI learns to control a bowl to catch falling fruit. The primary goal is to visualize and understand the process of training neural networks generated by genetic algorithms to master the game.

You can either train a new batch of neural networks from scratch or observe the performance of a pre-trained model that has already achieved a high level of fitness.

## üåü Features

* **NEAT Algorithm Implementation**: Utilizes the `neat-python` library to evolve neural networks.
* **Pygame-based Game**: A simple and interactive game environment for training and visualization.
* **AI Training Mode**: Train your own neural networks to catch fruit. The AI learns through trial and error, optimizing its strategy over generations.
* **Pre-trained Model**: Option to run the game with a saved, high-performing neural network.
* **Configurable Parameters**: The NEAT algorithm's parameters can be fine-tuned via the `config.ini` file.
* **Game Mechanics**:
    * The bowl can move left or right to catch falling fruit.
    * Score increases with each fruit caught.
    * The game resets or ends after a certain number of misses or when a target score is achieved during training.

## üß† How it Works

The project integrates the NEAT algorithm with the Fruit Catcher game.

1.  **Game Environment (`assets/game.py`, `assets/fruit.py`, `assets/bowl.py`)**:
    * `Fruit` objects fall from the top of the screen at a constant velocity. When a fruit is missed and hits the bottom, or when it's caught, it resets to a new random horizontal position at the top.
    * The `Bowl` is controlled by the AI (or player) and moves horizontally to intercept the fruit.
    * The `Game` class manages the game state, score, misses, and interactions between the fruit and the bowl.

2.  **NEAT AI (`main.py`)**:
    * **Inputs to the Neural Network**: The AI makes decisions based on:
        * The bowl's current x-position.
        * The fruit's current y-position.
        * The absolute horizontal distance between the center of the bowl and the center of the fruit.
    * **Outputs from the Neural Network**: The network outputs two values. The AI chooses the action corresponding to the higher output value:
        * Move Left
        * Move Right
    * **Training (`train_ai` function)**:
        * Genomes (representing individual neural networks) are evaluated based on their performance in the game.
        * Fitness is calculated primarily based on the score achieved. A genome's run ends if it misses too many fruits (e.g., 3 misses) or reaches a high score (e.g., >50), at which point its fitness is recorded.
        * The NEAT algorithm then uses these fitness scores to select, mutate, and reproduce genomes, aiming to create better-performing networks in subsequent generations.
    * **Testing (`test_ai` function)**: Allows you to see the best-performing saved network in action.
    * **Persistence**: The best network found during training can be saved to a file (`best_network.pickle`) and loaded later. Checkpoints of the training process are also saved (`neat-checkpoint-X`).

## üöÄ Getting Started

### Prerequisites

* Python 3.x
* Pygame
* NEAT-Python

You can typically install the libraries using pip:

```bash
pip install pygame neat-python
```

### Running the Project

1.  **Clone the repository** (if applicable) or **download the files**.

2.  **Navigate to the project directory** in your terminal or command prompt.

3.  **To run the pre-trained AI:**

    * First, ensure the file `best_network.pickle` is present in your project directory.
    * Next, open the `main.py` file. You need to make sure the line `run_game_as_ai(config)` is **not** commented out, and the line `run_neat(config)` **is** commented out. It should look like this:

        ```python
        if __name__ == "__main__":
            # ... (other code like config setup) ...

            # To train AI (this should be commented out to test the pre-trained AI)
            # run_neat(config)

            # To test AI (this should be active)
            run_game_as_ai(config)
        ```
    * Finally, run the script from your terminal:

        ```bash
        python main.py
        ```
4.  **To train your own AI:**

    * First, open the `main.py` file. You need to make sure the line `run_neat(config)` is **not** commented out, and the line `run_game_as_ai(config)` **is** commented out. It should look like this:

        ```python
        if __name__ == "__main__":
            # ... (other code like config setup) ...

            # To train AI (this should be active)
            run_neat(config)

            # To test AI (this should be commented out to train a new AI)
            # run_game_as_ai(config)
        ```
    * Inside the `run_neat` function in `main.py`, you can also choose whether to start training from scratch or restore from a checkpoint. Modify these lines as needed:

        ```python
        # To run from a checkpoint (uncomment the first line, comment the second)
        # p = neat.Checkpointer.restore_checkpoint('neat-checkpoint-35')

        # To run anew (uncomment the first line, comment the second if you were using a checkpoint)
        p = neat.Population(config)
        ```
    * Finally, run the script from your terminal:

        ```bash
        python main.py
        ```
    * The training process will then begin. You will see statistics printed to your console. The system will save checkpoint files periodically (e.g., `neat-checkpoint-X`), and once the training completes or meets its criteria, the best performing genome will be saved as `best_network.pickle`.

## ‚öôÔ∏è Configuration

The NEAT algorithm's behavior is controlled by the `config.ini` file. This file contains various parameters for:

* **NEAT**: Basic settings like `fitness_criterion`, `fitness_threshold`, `pop_size`.
* **DefaultStagnation**: Parameters controlling species stagnation.
* **DefaultReproduction**: Settings for elitism and survival threshold.
* **DefaultGenome**: A comprehensive set of parameters defining the structure and mutation rates of genomes, including:
    * Activation functions (`activation_default`, `activation_mutate_rate`).
    * Node aggregation (`aggregation_default`).
    * Bias and weight initialization and mutation (`bias_init_mean`, `weight_mutate_power`, etc.).
    * Connection probabilities (`conn_add_prob`, `conn_delete_prob`).
    * Network topology (`num_hidden`, `num_inputs`, `num_outputs`, `feed_forward`).

Feel free to experiment with these parameters to observe their impact on the AI's learning process.

## üìÇ Files in the Project

* **`main.py`**: The main script to run the game, train the AI, or test a pre-trained model. Contains the NEAT integration logic.
* **`config.ini`**: Configuration file for the NEAT algorithm.
* **`assets/`**: Directory containing game-specific modules.
    * `game.py`: Defines the main `Game` class, managing game flow, drawing, score, and collisions.
    * `bowl.py`: Defines the `Bowl` class, its properties, and drawing logic.
    * `fruit.py`: Defines the `Fruit` class, its properties (like falling behavior), and drawing logic.
* **`best_network.pickle`**: (Generated after training) Stores the best performing neural network.
* **`neat-checkpoint-*`**: (Generated during training) Checkpoint files to resume training.
* **`README.md`**: This file.

## üõ†Ô∏è Technologies Used

* **Python**: The core programming language.
* **Pygame**: A cross-platform set of Python modules designed for writing video games.
* **NEAT-Python**: A Python implementation of the NEAT (NeuroEvolution of Augmenting Topologies) algorithm.

---
